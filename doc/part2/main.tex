\documentclass[
	a4paper
]{scrreprt}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{textcomp, expdlist, array, colortbl, xcolor}
\usepackage[pdftex]{graphicx}
\usepackage[TS1, T1]{fontenc}
\usepackage{palatino} % Schriftart
\usepackage{parskip} %Erste Zeile eines Paragrafen nicht einrücken

\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}

% Snippets settings
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{magenta}\ttfamily,
	morecomment=[l][\color{magenta}]{\#}
}


\begin{document}
\sffamily % Whole document sans-serif


% Titelseite
\begin{titlepage}
	\centering
	\includegraphics[width=0.8\textwidth]{./images/logo_hska.png}\par\vspace{1cm}
	\vspace{1cm}
	
	{\scshape\Large Systemnahes Programmieren\par}
	\vspace{1.5cm}
	
	{\huge\textbf{Compiler}\par}
	\vspace{2cm}
	
	{\Large\itshape Timo Blust, 48594\par}
	{\Large\itshape Gennadi Eirich, 50629\par}
	{\Large\itshape Tim Essig, 49683\par\par}
	\vspace{2cm}
	
	{\Large\itshape Gruppe 17 (WS 15/16)\par}
	
	\vfill

	% Bottom of the page
	{\large \today\par}
\end{titlepage}


% Inhaltsverzeichnis
\tableofcontents

% Scanner
\chapter{Scanner}
\section{State Machine}
Da im zweiten Teil des Kompiler-Projekts neue Schlüsselworter hinzukommen, muss zunächst der Token Scanner (der Verwalter der Automaten) angepasst werden. Durch die modulare Struktur des Token Scanners ist dies jedoch mit geringem Aufwand möglich, da jedes Token (also auch jedes Schlüsselwort) einen eigenen Automaten besitzt.

Die Automaten für die neuen Schlüsselwörter    
\begin{lstlisting}     
  int
  else
  read
  write
\end{lstlisting}    
können mithilfe der statischen Funktion \lstinline{StateMachine::createString} generiert werden. Diese Funktion erzeugt einen Zustandsautomaten, welcher genau die übergebenen Strings akzeptiert. Der Automat für das Schlüsselwort \lstinline{else} wird zum Beispiel so erzeugt:
\begin{lstlisting}
StateMachine::createString(Token::KW_ELSE, 
                           new const char*[2]{ "ELSE", "else" }, 
                           2);
\end{lstlisting}

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{./images/statemachine.png}
\caption{Vereinfachtes Klassendiagramm von StateMachine}
\end{figure}

\chapter{Parser}
Der Parser hat die Aufgabe, aus der Tokensequenz die der Scanner liefert, einen Strukturbaum zu erstellen, hierbei prüft er auch die syntaktische Korrektheit. Der Datenfluss ist wie folgt: Der Parser fordert die Tokens vom Scanner an. Der Parser führt nach der Erstellung des Strukturbauems ebenfalls einen Typenprüfung durch und generiert den Code für die VM.
\section{Parse Tree}
Der Parser hat die Aufgabe aus den Tokens, welche der Scanner liefert, einen ParseTree auf zu spannen.  Um dies umzusetzen schaut der Parser immer ein Token voraus, somit wird die Ableitung eindeutig. Der Parser startet mit dem Startsymbol \textit{PROG} und erzeugt von da ausgehen für jede erkannte Regel einen neuen Teilbaum.\\

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./diagramms/parser.pdf}
\caption{Klassendiagramm des ParseTree}
\label{parseTree}
\end{figure}


\section{Type Checking}
Nach der erfolgreichen Generierung des Parse Trees erolgt eine Typ-Prüfung. Hierbei wird geprüft, ob sämtliche Ausdrückte semantisch korrekt sind. Wird zum Beispiel ein Identifier mehrfach definiert (egal ob vom selben Typ oder verschiedenen Typen), ist es Aufgabe des Type Checks diesen Fehler zu ermittlen und zu melden.

Folgende Punkte werden während des Type Checks geprüft:
\begin{itemize}
\item Mehrfache Definition des gleichen Identifiers
\item Inkompatible Datentypen (z.B. einer Variable vom Typ Integer-Array wird ein Wert vom Typ Integer zugewiesen)
\item Verwendung von undefinierten Identifiern
\item Ungültige Länge in Arraydefinitionen (z.B. \lstinline{int[0] toSmall;})
\end{itemize}

Das Ablaufdiagramm in Abbildung \ref{TypeCheck1} und \ref{TypeCheck2} zeigt die Funktionsweise der Typ-Prüfung.

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./images/TypeCheck1.png}
\caption{Ablaufdiagramm des Type Checks (Teil 1)}
\label{TypeCheck1}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{./images/TypeCheck2.png}
\caption{Ablaufdiagramm des Type Checks (Teil 2)}
\label{TypeCheck2}
\end{figure}


    \section{Code Generation}
Die Klasse \textit{CodeGeneration} kümmert sich um die Codegenerierung. Dafür stellt die Klasse eine öffentliche Methode:
\begin{lstlisting}
void generate(const Node* tree, std::ostream& out);
\end{lstlisting}

Dieser Klasse wird der Wurzelknoten des \textit{ParseTree}, und ein \textit{std::ostream} übergeben.

Für den übergebenen Knoten wird der jeweils entsprechende Code generiert und in den \textit{std::ostream} geschrieben. Dieses kann z.B. das \textit{std::cout} (Konsole) oder auch eine Datei \textit{std::oftream} sein.\\
Für Debug Zwecke wurde \textit{std::cout} verwendet. Um eine Datei für den Code zu erstellen, die der Interpreter lesen kann \textit{std::ofstream}.

Sollte der Übergeben Knoten aus weiteren Knoten bestehen, wird für den jeweiligen Knoten, die methode \textit{generate} aufgerufen. Damit ist die Abarbeitung rekursiv und alle Knoten, die am Wurzelknoten hängen werden in sich hirarchisch abgearbeitet. Sollte der Knoten zu einem Endknoten gelangen endet die Rekursion. Entweder ist die Codegenerierung zu ende oder es wird der nächste Knoten bearbeitet, bis alle Knoten abgearbeitet wurden.

Innerhalb der \textit{generate} Funktion befinden sich ein \textbf{switch} Statement, das je nach Knotentyp (Prog, Decls, Array, ...) den entsprechenden Code generiert. Im Falle eines leeren Knoten \textit{nullptr} oder einem Knote des Typs \textit{Nil} wird die Rekursion unterbrochen.

Die jeweiligen Regeln für die Codegenerierung sind dem Aufgabenblatt zu entnehmen. 


\begin{center}
	\includegraphics[width=0.3\textwidth]{./images/code_generation.png}
\end{center}

\subsection{Erzeugung eindeutiger Identifier}
Für die \textbf{JMP} und \textbf{JIN} Befehle werden eindeutige Identifier benötigt. Zu diesen eindeutigen Label wird bei der Ausführung je nach Bedingung gesprungen
\begin{lstlisting}
const char* CodeGenerator::_createLabel()
{
const int digitCount = _labelCount > 0 ? log10(_labelCount) + 1 : 1;
const auto size = strlen("lbl") + digitCount;
auto label = new char[size + 1];

// Fill label
sprintf(label, "lbl%u", _labelCount);

// Terminate label
label[size] = 0;

// Increment label count
_labelCount++;
return label;
}
\end{lstlisting}

\section{Ausführung}
Gebaut wird das Programm mit \textbf{Makefile}:
\begin{lstlisting}
$ make 			// build project
\end{lstlisting}

Alternativ können die Makefiles auch mit \textbf{CMake} generiert werden:
\begin{lstlisting}
$ mkdir build && cd build 	// create build directory
$ cmake ..			// generate makefiles
$ make				// build project
\end{lstlisting}

Für die Ausführung müssen dem Programm zwei Parameter übergeben werden.

\begin{enumerate}
	\item Eingabedatei (Sourcecode)
	\item Ausgabedatei (Generierter Code)
\end{enumerate}

\begin{lstlisting}
$ cd bin		// target directory
$ ./HsKA-Compiler input.txt output.code
\end{lstlisting}


\end{document}